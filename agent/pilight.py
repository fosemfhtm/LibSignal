from . import RLAgent
from common.registry import Registry
from agent import utils
import numpy as np
import os
import random
from collections import deque
import gym

from generator import LaneVehicleGenerator, IntersectionPhaseGenerator, IntersectionVehicleGenerator



@Registry.register_model('pilight')
class PiLightAgent(RLAgent):
    '''
    PiLightAgent determines each intersection's action with its own intersection information.
    '''
    def __init__(self, world, rank):
        super().__init__(world, world.intersection_ids[rank])

        self.world = world
        self.sub_agents = 1
        self.rank = rank

        self.num_phase = len(self.inter.phases)

        # get generator for each PiLightAgent
        inter_id = self.world.intersection_ids[self.rank]
        inter_obj = self.world.id2intersection[inter_id]
        self.inter = inter_obj

        self.lanelinks = self.inter.lanelinks
        self.startlanes = list(set(lanelink[0] for lanelink in self.lanelinks))
        self.endlanes = list(set(lanelink[1] for lanelink in self.lanelinks))

        self.ob_generator = LaneVehicleGenerator(self.world,  self.inter, ['lane_count', "lane_waiting_count", "lane_vehicle_distance"], in_only=False, average=None)
        self.ob_lanes = np.array(self.ob_generator.lanes).flatten().tolist()

        self.phase_generator = IntersectionPhaseGenerator(world,  self.inter, ["phase"],
                                                          targets=["cur_phase"], negative=False)
        self.reward_generator = LaneVehicleGenerator(self.world,  self.inter, ["lane_waiting_count"],
                                                     in_only=True, average='all', negative=True)
        self.action_space = gym.spaces.Discrete(len(self.world.id2intersection[inter_id].phases))

        self.ob_length = self.ob_generator.ob_length

        self.inlane_code = ''
        self.outlane_code = ''

        

    def __repr__(self):
        return "PiLight Agent"
    
    def inject_code(self, inlane_code, outlane_code):
        self.inlane_code = inlane_code
        self.outlane_code = outlane_code

    def ob_transform(self, ob):
        '''
        ob_transform
        Transform observation into desired format.

        :param ob: original observation
        '''
        l = self.ob_generator.ob_length//3
        num_vehicle = ob[0:l]
        num_waiting_vehicle = ob[l:2*l]
        vehicle_dist = ob[2*l:3*l]


        inlane_2_num_vehicle = []
        outlane_2_num_vehicle = []
        inlane_2_num_waiting_vehicle = []
        inlane_2_vehicle_dist = []
        outlane_2_vehicle_dist = []

        for start_lane in self.startlanes:
            inlane_2_num_vehicle.append(num_vehicle[self.ob_lanes.index(start_lane)])
            inlane_2_num_waiting_vehicle.append(num_waiting_vehicle[self.ob_lanes.index(start_lane)])
            inlane_2_vehicle_dist.append(vehicle_dist[self.ob_lanes.index(start_lane)])
        for end_lane in self.endlanes:
            outlane_2_num_vehicle.append(num_vehicle[self.ob_lanes.index(end_lane)])
            outlane_2_vehicle_dist.append(vehicle_dist[self.ob_lanes.index(end_lane)])

        return inlane_2_num_vehicle, outlane_2_num_vehicle, inlane_2_num_waiting_vehicle, inlane_2_vehicle_dist, outlane_2_vehicle_dist

    def reset(self):
        pass

    def get_ob(self):
        '''
        get_ob
        Get observation from environment.

        :param: None
        :return x_obs: observation generated by ob_generator
        '''
        x_obs = []
        x_obs.append(self.ob_generator.generate())
        x_obs = np.array(x_obs)
        return x_obs

    def get_reward(self):
        '''
        get_reward
        Get reward from environment.

        :param: None
        :return rewards: rewards generated by reward_generator
        '''
        rewards = []
        rewards.append(self.reward_generator.generate())
        rewards = np.squeeze(np.array(rewards)) * 12
        return rewards

    def get_phase(self):
        '''
        get_phase
        Get current phase of intersection(s) from environment.

        :param: None
        :return phase: current phase generated by phase_generator
        '''
        phase = []
        phase.append(self.phase_generator.generate())
        phase = (np.concatenate(phase)).astype(np.int8)
        return phase

    def get_action(self, ob, phase, test=False):
        '''
        get_action
        Generate action.

        :param ob: observation
        :param phase: current phase
        :param test: boolean, decide whether is test process
        :return action: action that has the highest score
        '''    

        lanelink_values = {}
        for lanelink in self.inter.lanelinks:
            lanelink_values[lanelink] = self._get_value_for_lanelink(ob, lanelink)

        phase_values = self._aggregate_for_each_phase(lanelink_values)
        action = phase_values.argmax()
        return action

    def _get_value_for_lanelink(self, ob, lanelink):
        inlane_2_num_vehicle, outlane_2_num_vehicle, inlane_2_num_waiting_vehicle, inlane_2_vehicle_dist, outlane_2_vehicle_dist = self.ob_transform(ob)
        value = [0]
        start_lane_name, end_lane_name = lanelink[0], lanelink[1]
        index = self.startlanes.index(start_lane_name)
        exec(self.inlane_code)
        index = self.endlanes.index(end_lane_name)
        exec(self.outlane_code)
        return value[0]

    def _aggregate_for_each_phase(self, lanelink_values):
        phase_values = np.zeros(self.num_phase)
        for phase_id in range(self.num_phase):
            for lanelink in self.inter.phase_available_lanelinks[phase_id]:
                phase_values[phase_id] += lanelink_values[lanelink]
        return phase_values

    def sample(self):
        '''
        sample
        Sample action randomly.

        :param: None
        :return: action generated randomly.
        '''
        return np.random.randint(0, self.action_space.n, self.sub_agents)

    def train(self):
        '''
        train
        Train the agent, optimize the action generated by agent.

        :param: None
        :return: value of loss
        '''
        pass


    def load_model(self, e):
        '''
        load_model
        Load model params of an episode.

        :param e: specified episode
        :return: None
        '''
        model_name = os.path.join(Registry.mapping['logger_mapping']['path'].path,
                                  'model', f'{e}_{self.rank}.pt')
        self.model = self._build_model()
        self.model.load_state_dict(torch.load(model_name))
        self.target_model = self._build_model()
        self.target_model.load_state_dict(torch.load(model_name))

    def save_model(self, e):
        '''
        save_model
        Save model params of an episode.

        :param e: specified episode, used for file name
        :return: None
        '''
        path = os.path.join(Registry.mapping['logger_mapping']['path'].path, 'model')
        if not os.path.exists(path):
            os.makedirs(path)
        model_name = os.path.join(path, f'{e}_{self.rank}.pt')
        torch.save(self.target_model.state_dict(), model_name)



